package abr.teleop;
import android.util.Log;

/**
 * * **********************************************************************
 *
 * Copyright (c) 2014 Regents of the University of California. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The names of its contributors may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * **********************************************************************
 * Class ghostWave provides methods for a spike wave front algorithm.
 * Algorithm will explore an environment and plan paths through the
 * environment. Uses spike wave front algorithm to plan paths. A method
 * is provided to explore regions of the environment. Another method is
 * provided to return the lowest cost path.
 *
 * @author Jeff Krichmar, Dept of Cognitive Sciences, UC Irvine
 * @version 18 June 2016
 */

import java.util.ArrayList;

public class ghostWave
{
    // instance variables
    private double [][] v;           // membrane potential
    private double [][] u;           // recovery variable
    private double [][] I;           // recovery variable
    private double [][][][]wgt;      // weight matrix
    private double [][][][]delayBuffer;      // weight matrix
    private double [][]map;
    private int sizeX;
    private int sizeY;
    private static final double W_INIT = 5.0f;
    private static final double SPIKE = 1.0f;
    private static final double REFRACTORY = -5.0f;
    ArrayList<aerType> aer;   // spike table

    /**
     * Constructor for objects of class ghostWave
     */
    public ghostWave(double [][]initMap)
    {
        this.sizeX = initMap.length;
        this.sizeY = initMap[0].length;

        // initialize instance variables
        v = new double[sizeX][sizeY];
        u = new double[sizeX][sizeY];
        I = new double[sizeX][sizeY];
        map = new double[sizeX][sizeY];

        for (int i = 0; i < sizeX; i++) {
            for (int j = 0; j < sizeY; j++) {
                v[i][j] = 0.0f;
                u[i][j] = 0.0f;
                I[i][j] = 0.0f;
                map[i][j] = initMap[i][j];
            }
        }

        wgt = new double[sizeX][sizeY][sizeX][sizeY];
        delayBuffer = new double[sizeX][sizeY][sizeX][sizeY];

        // Clear the weight matrix and delay buffer
        for (int i = 0; i < sizeX; i++) {
            for (int j = 0; j < sizeY; j++) {
                for (int m = 0; m < sizeX; m++) {
                    for (int n = 0; n < sizeY; n++) {
                        wgt[i][j][m][n] = 0.0f;
                        delayBuffer[i][j][m][n] = 0.0;
                    }
                }
            }
        }

        // Connect each neuron to its neighbor
        for (int i = 0; i < sizeX; i++) {
            for (int j = 0; j < sizeY; j++) {
                for (int m = -1; m <= 1; m++) {
                    for (int n = -1; n <= 1; n++) {
                        if (i+m >= 0 && i+m < sizeX && j+n >= 0 && j+n < sizeY && (m != 0 || n != 0)) {
                            wgt[i][j][i+m][j+n] = W_INIT;
                        }
                    }
                }
            }
        }
    }

    /**
     * spikeWave - Calculates a path using a spiking neuron wave front
     * algorithm. The cost of traversal is reflected in the axonal delays
     * between neurons.
     *
     * @param start - x and y coordinates of starting location.
     * @param end - x and y coordinates of ending location.
     * @return path - path generated by spike wave front.
     */
    public ArrayList<aerType> spikeWave (aerType start, aerType end)
    {
        ArrayList<aerType> aer = new ArrayList<aerType>();
        ArrayList<aerType> path = new ArrayList<aerType>();
        ArrayList<aerType> currentSpikes;

        boolean foundGoal = false;
        int timeStep = 0;
        int x, y;

        aer = new ArrayList<aerType>();   // clear the spike table
        path = new ArrayList<aerType>();

        for (int i = 0; i < sizeX; i++) {
            for (int j = 0; j < sizeY; j++) {
                v[i][j] = 0.0f;
                u[i][j] = 0.0f;
                I[i][j] = 0.0f;
            }
        }

        // Clear the delay buffer
        for (int i = 0; i < sizeX; i++) {
            for (int j = 0; j < sizeY; j++) {
                for (int m = 0; m < sizeX; m++) {
                    for (int n = 0; n < sizeY; n++) {
                        delayBuffer[i][j][m][n] = 0.0f;
                    }
                }
            }
        }

        // the spike wave is initiated from the starting location
        v[start.getX()][start.getY()] = 1;

        while (!foundGoal)
        {
            timeStep = timeStep + 1;
            currentSpikes = getSpikes (); // update the AER and get the number of spikes

            /* Neurons that spike send their spike to their post-synaptic targets.
             * The weights are updated and the spike goes in a delay buffer to
             * targets. The neuron's recovery variable is set to its refractory value.
             */
            if (currentSpikes.size() > 0)
            {
                for (int i = 0; i < currentSpikes.size(); i++)
                {
                    x = currentSpikes.get(i).getX();
                    y = currentSpikes.get(i).getY();

                    // System.out.println(x + " " + y);
                    Log.d("abr_debug", "spikeWave: " + x + " " + y);

                    aer.add(new aerType(x, y, timeStep, -1));

                    u[x][y] = REFRACTORY;
                    for (int j = 0; j < sizeX; j++)
                    {
                        for (int k = 0; k < sizeY; k++)
                        {
                            delayRule(1.0, x, y, map[x][y]);
                            delayBuffer[x][y][j][k] = (int)(wgt[x][y][j][k] + 0.5);
                            if (x == end.getX() && y == end.getY())
                            {
                                foundGoal = true;
                            }
                        }
                    }
                }
            }

            /* if the spike wave is still propagating, get the synaptic input for
             *
             * all neurons. Synaptic input is based on recovery variable, and spikes
             * that are arriving to the neuron at this time step.
             */
            if (!foundGoal)
            {
                for (int i = 0; i < sizeX; i++)
                {
                    for (int j = 0; j < sizeY; j++)
                    {
                        I[i][j] = u[i][j];
                        for (int m = 0; m < sizeX; m++)
                        {
                            for (int n = 0; n < sizeY; n++)
                            {
                                if (delayBuffer[m][n][i][j] == 1 && wgt[m][n][i][j] > Double.MIN_VALUE)
                                {
                                    ++I[i][j];
                                }
                                --delayBuffer[m][n][i][j];
                                if (delayBuffer[m][n][i][j] < 0)
                                {
                                    delayBuffer[m][n][i][j] = 0.0f;
                                }
                            }
                        }
                        v[i][j] += I[i][j];
                        ++u[i][j];
                        if (u[i][j] > 0)
                        {
                            u[i][j] = 0.0f;
                        }
                    }
                }
            }

        }

        path = getPath(aer, start, end);

        return path;
    }

    public ArrayList<aerType> getPath(ArrayList<aerType> spks, aerType start, aerType end)
    {
        ArrayList<aerType> path = new ArrayList<aerType>();
        aerType refSpike = new aerType(end.getX(), end.getY(), 0, map[end.getX()][end.getY()]);
        path.add(refSpike);
        boolean found = false;
        double SMALL_VALUE = 0.000001;
        int inx = 0;
        ArrayList<aerType> spkList = new ArrayList<>();

        while (euclidDist(refSpike,start) > 1.5)
        {
            // get the time of the last spike and
            // refSpike = spks.get(spks.size()-1);
            int timeLastSpike = spks.get(spks.size()-1).getTimeStamp();

            for (int i = timeLastSpike-1; i > 0; i--)
            {
                // get a list of all neurons that spiked this timestep and that connected to the
                // spiking neuron
                spkList = new ArrayList<>();
                found = false;
                for (int j = 0; j < spks.size(); j++) {
                    if (spks.get(j).getTimeStamp() == i && euclidDist(refSpike, spks.get(j)) < 1.5)  {
                        spkList.add(spks.get(j));
                        found = true;
                    }
                }
                // now we got a list, make a tie breaker
                if (found) {
                    double cost = Double.MAX_VALUE;
                    double dist = Double.MAX_VALUE;

                    for (int j = 0; j < spkList.size(); j++) {

                        // find the neuron with the lowest cost. subtract off a small amount just to be sure
                        // it is significantly less than the current lowest cost.
                        if (map[spkList.get(j).getX()][spkList.get(j).getY()] < (cost-SMALL_VALUE)) {
                            cost = map[spkList.get(j).getX()][spkList.get(j).getY()];
                            dist = euclidDist(start, spkList.get(j));
                            inx = j;
                        }
                        // if there is another neuron with the same cost, pick the neuron that is closer to the start
                        else if (Math.abs (map[spkList.get(j).getX()][spkList.get(j).getY()] - cost) < SMALL_VALUE && euclidDist(start, spkList.get(j)) < dist) {
                            cost = map[spkList.get(j).getX()][spkList.get(j).getY()];
                            dist = euclidDist(start, spkList.get(j));
                            inx = j;
                        }
                    }
                    path.add(spkList.get(inx));
                    refSpike = spkList.get(inx);
                    // System.out.println("path: " + spkList.get(inx).getX() + " " + spkList.get(inx).getY());
                    Log.d("abr_debug", "getPath: " + spkList.get(inx).getX() + " " + spkList.get(inx).getY());
                }
            }
        }

        return path;
    }

    private double euclidDist(aerType v1, aerType v2)
    {
        return Math.sqrt(Math.pow(v1.getX()-v2.getX(),2.0) + Math.pow(v1.getY()-v2.getY(),2.0));
    }

    /* delayRule - Calculates a delta function for the weights. The weights hold
     * the axonal delay between neurons. Given a presynaptic index, the method
     * updates all the non-zero postsynaptic weights.
     *
     * @param learnRate - learning rate.
     * @param inx1 - first "from" index into the weight matrix.
     * @param inx2 - second "from" index into the weight matrix.
     * @param value - value from the cost map.
     *
     */
    public void delayRule(double learnRate, int inx1, int inx2, double value)
    {
        for (int i = 0; i < sizeX; i++)
        {
            for (int j = 0; j < sizeY; j++)
            {
                if (wgt[inx1][inx2][i][j] > Double.MIN_VALUE)
                {
                    wgt[inx1][inx2][i][j] += learnRate * (value - wgt[inx1][inx2][i][j]);
                }
            }
        }
    }

    /* getSpikes - finds all the neurons that are currently spiking
     *
     * @return - an AER array of spikes. Timestep and cost are not necessary.
     */
    private ArrayList<aerType> getSpikes ()
    {
        ArrayList<aerType> spikes = new ArrayList<aerType>();

        for (int i = 0; i < sizeX; i++)
        {
            for (int j = 0; j < sizeY; j++)
            {
                if (v[i][j] > 0)
                {
                    spikes.add(new aerType(i, j, 0, -1));
                }
            }
        }
        return spikes;
    }
}
